package com.caipiao.common.pay.yizhi.common;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.apache.commons.lang.StringUtils;


public class TestUtil {
	
	
	/**
	 *double类型数乘以100
	 */
	public static Double doubleRide100(double d) {
		BigDecimal bg = new BigDecimal(d * 100);
		double doubleValue = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();
		return doubleValue;
	}

	/**
	 * 
	 * 方法用途: 对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序），并且生成url参数串<br>
	 * 实现步骤: <br>
	 * 
	 * @param paraMap
	 *            要排序的Map对象
	 * @param urlEncode
	 *            是否需要URLENCODE
	 * @param keyToLower
	 *            是否需要将Key转换为全小写 true:key转化成小写，false:不转化
	 * @return
	 */
	public static String formatUrlMap(Map<String, String> paraMap, boolean urlEncode, boolean keyToLower) {
		String buff = "";
		Map<String, String> tmpMap = paraMap;
		try {
			List<Map.Entry<String, String>> infoIds = new ArrayList<Map.Entry<String, String>>(tmpMap.entrySet());
			// 对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序）
			Collections.sort(infoIds, new Comparator<Map.Entry<String, String>>() {

				@Override
				public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
					return (o1.getKey()).toString().compareTo(o2.getKey());
				}
			});
			// 构造URL 键值对的格式
			StringBuilder buf = new StringBuilder();
			for (Map.Entry<String, String> item : infoIds) {
				if (StringUtils.isNotBlank(item.getKey())) {
					String key = item.getKey();
					String val = item.getValue();
					if (urlEncode) {
						val = URLEncoder.encode(val, "utf-8");
					}
					if (keyToLower) {
						buf.append(key.toLowerCase() + "=" + val);
					} else {
						buf.append(key + "=" + val);
					}
					buf.append("&");
				}

			}
			buff = buf.toString();
			if (buff.isEmpty() == false) {
				buff = buff.substring(0, buff.length() - 1);
			}
		} catch (Exception e) {
			return null;
		}
		return buff;
	}
	   
	   /**
	    * 对字符串md5加密
	    *
	    * @param str
	    * @return
	    */
	   public static String getMD5(String str){
		   MessageDigest md5 = null;  
		   try{  
		      md5 = MessageDigest.getInstance("MD5");  
		   }catch (Exception e){  
		     System.out.println(e.toString());  
		     e.printStackTrace();  
		     return "";  
		   }  
		   char[] charArray = str.toCharArray();  
		   byte[] byteArray = new byte[charArray.length];
		   for (int i = 0; i < charArray.length; i++)  
		     byteArray[i] = (byte) charArray[i];  
		   byte[] md5Bytes = md5.digest(byteArray);  
		   StringBuffer hexValue = new StringBuffer();  
		   for (int i = 0; i < md5Bytes.length; i++){  
		     int val = ((int) md5Bytes[i]) & 0xff;  
		     if (val < 16)  
		       hexValue.append("0");  
		     hexValue.append(Integer.toHexString(val));  
		   }  
		   return hexValue.toString();
	   }
	   
	   /**
	     * 接口调用 GET
	     */
	   public static String sendGet(String GET_URL) {
		   String s=null;
			 try {
		            URL url = new URL(GET_URL);    // 把字符串转换为URL请求地址
		            HttpURLConnection connection = (HttpURLConnection) url.openConnection();// 打开连接
		            connection.connect();// 连接会话
		            // 获取输入流
		            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
		            String line;
		            StringBuilder sb = new StringBuilder();
		            while ((line = br.readLine()) != null) {// 循环读取流
		                sb.append(line);
		            }
		            br.close();// 关闭流
		            connection.disconnect();// 断开连接
		            System.out.println("接口调用 GET:"+sb.toString());
		            s=sb.toString();
		            return s;
		        } catch (Exception e) {
		            e.printStackTrace();
		            System.out.println("失败!");
		        }
			return null;
		}

	    /**
	     * 向指定 URL 发送POST方法的请求
	     * 
	     * @param url
	     *            发送请求的 URL
	     * @param param
	     *            请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
	     * @param charset         
	     *             发送和接收的格式       
	     * @return 所代表远程资源的响应结果
	     */
	    public static String sendPost(String url, String param,String charset) {
	    	PrintWriter out = null;
	        BufferedReader in = null;
	        String result = "";
	        String line;
	        StringBuffer sb=new StringBuffer();
	        try {
	            URL realUrl = new URL(url);
	            //如果是https请求,忽略SSL证书
	            if("https".equalsIgnoreCase(realUrl.getProtocol())){
	            	   SslUtils.ignoreSsl();
	            	}
	            // 打开和URL之间的连接 
	            URLConnection conn = realUrl.openConnection();
	            // 设置通用的请求属性 设置请求格式
	            conn.setRequestProperty("contentType", charset);  
	            conn.setRequestProperty("content-type", "application/x-www-form-urlencoded");
	            //设置超时时间
	            conn.setConnectTimeout( 60000);
	            conn.setReadTimeout( 60000);
	            // 发送POST请求必须设置如下两行
	            conn.setDoOutput(true);
	            conn.setDoInput(true);
	            // 获取URLConnection对象对应的输出流
	            out = new PrintWriter(conn.getOutputStream());
	            // 发送请求参数
	            out.print(param);
	            // flush输出流的缓冲
	            out.flush();
	            // 定义BufferedReader输入流来读取URL的响应    设置接收格式
	            in = new BufferedReader(new InputStreamReader(conn.getInputStream(),charset));
	            while ((line = in.readLine()) != null) {
	                sb.append(line);
	            }
	            result=sb.toString();
	        } catch (Exception e) {
	            System.out.println("发送 POST请求出现异常!"+e);
	            e.printStackTrace();
	        }
	        //使用finally块来关闭输出流、输入流
	        finally{
	            try{
	                if(out!=null){
	                    out.close();
	                }
	                if(in!=null){
	                    in.close();
	                }
	            }
	            catch(IOException ex){
	                ex.printStackTrace();
	            }
	        }
	        return result;
	    } 	   
	   
	   /**
	    * 获取现在时间
	    * @author haixin
	    * @return 返回时间类型 yyyy-MM-dd HH:mm:ss
	    * @throws ParseException 
	    */
	   public static Date getNowDate() throws ParseException {
		   SimpleDateFormat sd = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		   String dateTime=sd.format(new Date());
		   Date date=sd.parse(dateTime);
		   return date;
	   }  
	   
	   /**
	    * 生成两位随机数
	    * @author haixin
	    * @return 返回int类型 10-99
	    */
	   public static int random() {
			int max=99;
	        int min=10;
	        Random random = new Random();
	        int s = random.nextInt(max)%(max-min+1) + min;
	        return s;
		}
	   
	   /**
	     * 不够位数的在前面补0，保留num的长度位数字
	     * @param code
	     * @return
	     */
	    private static String autoGenericCode(String code, int num) {
	        String result = "";
	        // 保留num的位数
	        // 0 代表前面补充0
	        // num 代表长度为4     
	        // d 代表参数为正数型 
	        result = String.format("%0" + num + "d", Integer.parseInt(code));

	        return result;
	    }
	    
	    /**
	     * @author haixin.hu
	     * @param str：name1=value1&name2=value2类型字符串
	     * @return 返回类型：Map数组
	     * */
	    @SuppressWarnings("rawtypes")
		public static Map StrToMap(String str){
	    	String[] strs = str.split("&");
			Map<String, String> m = new HashMap<String, String>();
			for(String s:strs){
			String[] ms = s.split("=");
			m.put(ms[0], ms[1]);
			}
			return m;
	    }
}
